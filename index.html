<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Professional 3D Calculator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: radial-gradient(ellipse at center, #434343 0%, #000000 100%);
            font-family: 'Arial', sans-serif;
        }

        #three-container {
            width: 100%;
            height: 100vh;
            cursor: grab;
        }

        #three-container:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <div id="three-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // Calculator functionality
        let currentInput = '';
        let operator = '';
        let previousInput = '';
        let displayValue = '0';

        function updateDisplay(value) {
            displayValue = value || '0';
            updateDisplayMesh();
        }

        function appendToDisplay(value) {
            if (['+', '-', '*', '/'].includes(value)) {
                if (currentInput === '' && previousInput === '') return;
                if (operator && currentInput !== '') {
                    calculate();
                }
                operator = value;
                previousInput = currentInput || previousInput;
                currentInput = '';
                updateDisplay(previousInput + ' ' + (value === '*' ? '×' : value) + ' ');
            } else {
                currentInput += value;
                updateDisplay(displayValue === '0' ? value : displayValue + value);
            }
        }

        function calculate() {
            if (previousInput === '' || currentInput === '' || operator === '') return;
            
            let result;
            const prev = parseFloat(previousInput);
            const current = parseFloat(currentInput);
            
            switch (operator) {
                case '+':
                    result = prev + current;
                    break;
                case '-':
                    result = prev - current;
                    break;
                case '*':
                    result = prev * current;
                    break;
                case '/':
                    if (current === 0) {
                        updateDisplay('Error');
                        resetCalculator();
                        return;
                    }
                    result = prev / current;
                    break;
                default:
                    return;
            }
            
            updateDisplay(result.toString());
            previousInput = result.toString();
            currentInput = '';
            operator = '';
        }

        function clearDisplay() {
            updateDisplay('0');
            currentInput = '';
            operator = '';
            previousInput = '';
        }

        function deleteLast() {
            if (currentInput) {
                currentInput = currentInput.slice(0, -1);
                const newDisplay = displayValue.slice(0, -1);
                updateDisplay(newDisplay || '0');
            }
        }

        function resetCalculator() {
            setTimeout(() => {
                clearDisplay();
            }, 1500);
        }

        // Three.js 3D Scene
        let scene, camera, renderer, controls;
        let composer, renderPass, bloomPass;
        let calculatorGroup;
        let calculatorButtons = [];
        let displayTextMesh;
        let raycaster, mouse;

        function init3D() {
            const container = document.getElementById('three-container');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a1a);
            
            // Camera - professional angle
            camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(2, 6, 10);
            camera.lookAt(0, 0, 0);
            
            // Renderer with enhanced quality
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.physicallyCorrectLights = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.25;
            container.appendChild(renderer.domElement);

            // Post-processing (subtle cinematic bloom)
            composer = new THREE.EffectComposer(renderer);
            renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.35, // strength
                0.6,  // radius
                0.0   // threshold
            );
            composer.addPass(bloomPass);
            
            // Raycaster for interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            // Enhanced camera controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.03;
            controls.target.set(0, 0, 0);
            controls.minDistance = 6;
            controls.maxDistance = 20;
            controls.maxPolarAngle = Math.PI / 2.1;
            controls.minPolarAngle = Math.PI / 6;
            controls.autoRotate = false;
            controls.enablePan = false;
            
            setupProfessionalLighting();
            create3DCalculator();
            
            // Event listeners
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            
            animate();
        }

        function setupProfessionalLighting() {
            // Key light (main)
            const keyLight = new THREE.DirectionalLight(0xffffff, 2.5);
            keyLight.position.set(8, 12, 6);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 4096;
            keyLight.shadow.mapSize.height = 4096;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 50;
            keyLight.shadow.camera.left = -15;
            keyLight.shadow.camera.right = 15;
            keyLight.shadow.camera.top = 15;
            keyLight.shadow.camera.bottom = -15;
            keyLight.shadow.bias = -0.0001;
            scene.add(keyLight);
            
            // Fill light
            const fillLight = new THREE.DirectionalLight(0x87ceeb, 0.8);
            fillLight.position.set(-6, 8, 4);
            scene.add(fillLight);
            
            // Rim light
            const rimLight = new THREE.DirectionalLight(0xffffff, 1.0);
            rimLight.position.set(-4, 3, -8);
            scene.add(rimLight);
            
            // Ambient light
            const ambientLight = new THREE.AmbientLight(0x404040, 0.2);
            scene.add(ambientLight);
            
            // Environment reflection
            const envLight = new THREE.HemisphereLight(0x606060, 0x404040, 0.4);
            scene.add(envLight);
        }

        function create3DCalculator() {
            calculatorGroup = new THREE.Group();
            
            // Main calculator body - rounded rectangle with bevels
            const bodyShape = new THREE.Shape();
            const width = 5, height = 7, radius = 0.3;
            
            bodyShape.moveTo(-width/2 + radius, -height/2);
            bodyShape.lineTo(width/2 - radius, -height/2);
            bodyShape.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
            bodyShape.lineTo(width/2, height/2 - radius);
            bodyShape.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
            bodyShape.lineTo(-width/2 + radius, height/2);
            bodyShape.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
            bodyShape.lineTo(-width/2, -height/2 + radius);
            bodyShape.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);
            
            const extrudeSettings = {
                depth: 0.8,
                bevelEnabled: true,
                bevelSegments: 8,
                bevelSize: 0.05,
                bevelThickness: 0.05
            };
            
            const bodyGeometry = new THREE.ExtrudeGeometry(bodyShape, extrudeSettings);
            const bodyMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x2c2c2c,
                metalness: 0.2,
                roughness: 0.22,
                clearcoat: 0.9,
                clearcoatRoughness: 0.08,
                reflectivity: 0.35
            });
            
            const calcBody = new THREE.Mesh(bodyGeometry, bodyMaterial);
            calcBody.rotation.x = -Math.PI / 2;
            calcBody.position.y = 0;
            calcBody.castShadow = true;
            calcBody.receiveShadow = true;
            calculatorGroup.add(calcBody);

            // Chamfered top frame inset for realism
            const frameGeometry = new THREE.BoxGeometry(width - 0.25, 0.04, height - 0.25);
            const frameMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x1f1f1f,
                metalness: 0.25,
                roughness: 0.35,
                clearcoat: 0.4,
                clearcoatRoughness: 0.2
            });
            const topFrame = new THREE.Mesh(frameGeometry, frameMaterial);
            topFrame.position.set(0, 0.39, 0);
            topFrame.receiveShadow = true;
            calculatorGroup.add(topFrame);
            
            // Create recessed display area
            createDisplayArea();
            
            // Branding badge and power LED
            createBranding();
            createPowerLED();

            // Create flush buttons
            createFlushButtons();
            
            // Ground plane
            const groundGeometry = new THREE.PlaneGeometry(40, 40);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0x1a1a1a,
                metalness: 0.1,
                roughness: 0.8
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);
            
            scene.add(calculatorGroup);
        }

        function createDisplayArea() {
            // Display recess (carved into body)
            const displayRecessGeometry = new THREE.BoxGeometry(3.8, 0.12, 1.2);
            const displayRecessMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x0a0a0a,
                metalness: 0.05,
                roughness: 0.95
            });
            const displayRecess = new THREE.Mesh(displayRecessGeometry, displayRecessMaterial);
            displayRecess.position.set(0, 0.35, 2.4);
            calculatorGroup.add(displayRecess);
            
            // LED display screen (flush with recess)
            const displayScreenGeometry = new THREE.BoxGeometry(3.6, 0.02, 1);
            const displayScreenMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x020202,
                emissive: 0x001a00,
                emissiveIntensity: 0.15,
                metalness: 0,
                roughness: 0.1,
                transmission: 0.05,
                thickness: 0.01
            });
            const displayScreen = new THREE.Mesh(displayScreenGeometry, displayScreenMaterial);
            displayScreen.position.set(0, 0.36, 2.4);
            calculatorGroup.add(displayScreen);
            
            // Thin glass border around screen
            const bezelGeometry = new THREE.BoxGeometry(3.7, 0.022, 1.05);
            const bezelMaterial = new THREE.MeshPhysicalMaterial({
                color: 0x121212,
                metalness: 0.6,
                roughness: 0.4,
                clearcoat: 1,
                clearcoatRoughness: 0.15
            });
            const bezel = new THREE.Mesh(bezelGeometry, bezelMaterial);
            bezel.position.set(0, 0.361, 2.4);
            calculatorGroup.add(bezel);

            // Create the display text (flush with screen)
            createDisplayText();
        }

        function createDisplayText() {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 800;
            canvas.height = 200;
            
            // Clear canvas
            context.fillStyle = '#000000';
            context.fillRect(0, 0, canvas.width, canvas.height);
            
            // Set font and style
            context.font = 'bold 120px "Segment7Standard", "Courier New", monospace';
            context.fillStyle = '#6BFF6B';
            context.textAlign = 'right';
            context.textBaseline = 'middle';
            
            // Add subtle glow effect
            context.shadowColor = '#00ff88';
            context.shadowBlur = 24;
            
            // Draw text
            const text = displayValue.length > 10 ? displayValue.substring(0, 10) : displayValue;
            context.fillText(text, canvas.width - 40, canvas.height / 2);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.flipY = false;
            
            const textMaterial = new THREE.MeshBasicMaterial({ 
                map: texture, 
                transparent: true,
                opacity: 1,
                depthWrite: false
            });
            const textGeometry = new THREE.PlaneGeometry(3.5, 0.9);
            
            // Remove old text
            if (displayTextMesh) {
                calculatorGroup.remove(displayTextMesh);
            }
            
            displayTextMesh = new THREE.Mesh(textGeometry, textMaterial);
            displayTextMesh.position.set(0, 0.37, 2.41); // Flush with screen surface
            calculatorGroup.add(displayTextMesh);
        }

        function updateDisplayMesh() {
            createDisplayText();
        }

        function createFlushButtons() {
            const buttonLayout = [
                ['C', '⌫', '÷', '×'],
                ['7', '8', '9', '−'],
                ['4', '5', '6', '+'],
                ['1', '2', '3', '='],
                ['0', '', '.', '=']
            ];
            
            const buttonFunctions = [
                ['clear', 'delete', '/', '*'],
                ['7', '8', '9', '-'],
                ['4', '5', '6', '+'],
                ['1', '2', '3', 'equals'],
                ['0', '', '.', 'equals']
            ];
            
            const buttonColors = {
                'clear': { color: 0x3f3f3f, label: '#ffffff' },
                'delete': { color: 0x3f3f3f, label: '#ffffff' },
                '/': { color: 0x5c5c5c, label: '#ffffff' },
                '*': { color: 0x5c5c5c, label: '#ffffff' },
                '-': { color: 0x5c5c5c, label: '#ffffff' },
                '+': { color: 0x5c5c5c, label: '#ffffff' },
                'equals': { color: 0xff9500, label: '#ffffff' },
                'default': { color: 0x5a5a5a, label: '#ffffff' }
            };
            
            for (let row = 0; row < 5; row++) {
                for (let col = 0; col < 4; col++) {
                    if (row === 4 && col === 1) continue; // Skip empty space
                    
                    const func = buttonFunctions[row][col];
                    const label = buttonLayout[row][col];
                    if (!func || !label) continue;
                    
                    const colors = buttonColors[func] || buttonColors['default'];
                    
                    let xPos = -1.5 + col * 1.0;
                    let zPos = 1.2 - row * 0.8;
                    let buttonWidth = 0.8;
                    let buttonDepth = 0.6;
                    
                    // Special sizing
                    if (row === 4 && col === 0) { // Wide 0 button
                        buttonWidth = 1.8;
                        xPos = -1.0;
                    }
                    if (row === 3 && col === 3) { // Tall = button  
                        buttonDepth = 1.4;
                        zPos = zPos - 0.4;
                    }
                    
                    // Button recess (carved into body)
                    const buttonRecessGeometry = new THREE.BoxGeometry(buttonWidth, 0.08, buttonDepth);
                    const buttonRecessMaterial = new THREE.MeshPhysicalMaterial({
                        color: 0x1a1a1a,
                        metalness: 0.1,
                        roughness: 0.9
                    });
                    const buttonRecess = new THREE.Mesh(buttonRecessGeometry, buttonRecessMaterial);
                    buttonRecess.position.set(xPos, 0.35, zPos);
                    calculatorGroup.add(buttonRecess);
                    
                    // Flush button surface
                    const buttonSurfaceGeometry = new THREE.BoxGeometry(buttonWidth - 0.05, 0.02, buttonDepth - 0.05);
                    const buttonSurfaceMaterial = new THREE.MeshPhysicalMaterial({
                        color: colors.color,
                        metalness: 0.25,
                        roughness: 0.38,
                        clearcoat: 0.4,
                        clearcoatRoughness: 0.18
                    });
                    const buttonSurface = new THREE.Mesh(buttonSurfaceGeometry, buttonSurfaceMaterial);
                    buttonSurface.position.set(xPos, 0.36, zPos);
                    buttonSurface.castShadow = true;
                    calculatorGroup.add(buttonSurface);
                    
                    // Flush button label
                    const labelCanvas = document.createElement('canvas');
                    const labelContext = labelCanvas.getContext('2d');
                    labelCanvas.width = 200;
                    labelCanvas.height = 200;
                    
                    labelContext.fillStyle = 'transparent';
                    labelContext.fillRect(0, 0, labelCanvas.width, labelCanvas.height);
                    
                    labelContext.font = 'bold 90px Arial';
                    labelContext.fillStyle = colors.label;
                    labelContext.textAlign = 'center';
                    labelContext.textBaseline = 'middle';
                    labelContext.fillText(label, labelCanvas.width / 2, labelCanvas.height / 2);
                    
                    const labelTexture = new THREE.CanvasTexture(labelCanvas);
                    const labelMaterial = new THREE.MeshBasicMaterial({ 
                        map: labelTexture, 
                        transparent: true
                    });
                    const labelGeometry = new THREE.PlaneGeometry(buttonWidth - 0.1, buttonDepth - 0.1);
                    const labelMesh = new THREE.Mesh(labelGeometry, labelMaterial);
                    labelMesh.position.set(xPos, 0.37, zPos); // Flush with button surface
                    labelMesh.rotation.x = -Math.PI / 2;
                    calculatorGroup.add(labelMesh);
                    
                    // Store button data for interaction
                    buttonSurface.userData = { 
                        function: func, 
                        label: label,
                        originalY: 0.36,
                        originalColor: colors.color,
                        recess: buttonRecess,
                        labelMesh: labelMesh
                    };
                    
                    calculatorButtons.push(buttonSurface);
                }
            }
        }

        // Branding badge at the bottom left
        function createBranding() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 512; canvas.height = 128;
            ctx.fillStyle = 'rgba(0,0,0,0)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.font = 'bold 72px Poppins, Arial';
            ctx.fillStyle = '#e6e6e6';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText('CALC • PRO', 20, canvas.height / 2);

            const tex = new THREE.CanvasTexture(canvas);
            const material = new THREE.MeshBasicMaterial({ map: tex, transparent: true, depthWrite: false });
            const geo = new THREE.PlaneGeometry(1.8, 0.35);
            const mesh = new THREE.Mesh(geo, material);
            mesh.position.set(-1.6, 0.371, -2.8);
            mesh.rotation.x = -Math.PI / 2;
            calculatorGroup.add(mesh);
        }

        // Small power LED indicator (soft glow)
        function createPowerLED() {
            const ledGeo = new THREE.SphereGeometry(0.04, 16, 16);
            const ledMat = new THREE.MeshStandardMaterial({
                color: 0x00ff7f,
                emissive: 0x00ff7f,
                emissiveIntensity: 0.6,
                metalness: 0.1,
                roughness: 0.4
            });
            const led = new THREE.Mesh(ledGeo, ledMat);
            led.position.set(1.9, 0.382, -2.9);
            calculatorGroup.add(led);
        }

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(calculatorButtons);
            
            // Reset all buttons
            calculatorButtons.forEach(button => {
                button.position.y = button.userData.originalY;
                button.material.emissive.setHex(0x000000);
            });
            
            // Highlight hovered button
            if (intersects.length > 0) {
                const hoveredButton = intersects[0].object;
                hoveredButton.material.emissive.setHex(0x111111);
                document.body.style.cursor = 'pointer';
            } else {
                document.body.style.cursor = 'grab';
            }
        }

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(calculatorButtons);
            
            if (intersects.length > 0) {
                const clickedButton = intersects[0].object;
                const func = clickedButton.userData.function;
                
                // Button press animation
                clickedButton.position.y = clickedButton.userData.originalY - 0.02;
                clickedButton.material.emissive.setHex(0x333333);
                clickedButton.userData.labelMesh.position.y = 0.35;
                
                setTimeout(() => {
                    clickedButton.position.y = clickedButton.userData.originalY;
                    clickedButton.material.emissive.setHex(0x000000);
                    clickedButton.userData.labelMesh.position.y = 0.37;
                }, 100);
                
                // Execute calculator function
                switch(func) {
                    case 'clear':
                        clearDisplay();
                        break;
                    case 'delete':
                        deleteLast();
                        break;
                    case 'equals':
                        calculate();
                        break;
                    default:
                        appendToDisplay(func);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            composer.render();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        // Keyboard support
        document.addEventListener('keydown', function(event) {
            const key = event.key;
            
            if (key >= '0' && key <= '9' || key === '.') {
                appendToDisplay(key);
            } else if (['+', '-', '*', '/'].includes(key)) {
                appendToDisplay(key);
            } else if (key === 'Enter' || key === '=') {
                calculate();
            } else if (key === 'Escape') {
                clearDisplay();
            } else if (key === 'Backspace') {
                deleteLast();
            }
        });

        window.addEventListener('resize', onWindowResize);
        
        // Initialize
        init3D();
        updateDisplay('0');
    </script>
</body>
</html>